## 一些C++的面试问题 Q1

### #define和const的区别有那些

1. 作用域不同：
   - \#define定义的常量是一个预处理宏，它在编译之前被替换，作用域为定义处到文件结束。
   - const定义的常量是一个真正的变量，其作用域根据定义的位置而定，可以是局部或全局作用域。
2. 类型安全性：
   - \#define不具有类型检查，在预处理阶段只是简单地进行文本替换，容易导致一些潜在的错误。
   - const定义的常量具有类型检查，编译器会对其进行类型检查，提供更好的类型安全性。
3. 调试信息：
   - \#define在预处理阶段进行文本替换，因此在调试时无法查看使用#define定义的常量的值。
   - const定义的常量是真正的变量，可以被调试器识别并显示其值。



### C++中struct和class有什么区别

1. 默认的访问权限：
   - 在struct中，默认的成员变量和成员函数的访问权限是public的，意味着它们可以被外部访问。
   - 在class中，默认的成员变量和成员函数的访问权限是private的，意味着它们只能够在类的内部访问。
2. 继承方式：
   - 在struct中，继承的默认访问权限是public的，派生类可以访问基类的public和protected成员。
   - 在class中，继承的默认访问权限是private的，派生类只能够访问基类的public成员。


### C++中动态链接库和静态连接库的区别是什么？

#### 1. 链接时期

- **静态链接库**：在程序编译时，静态库的内容会被复制到最终的可执行文件中。当你运行程序时，不需要库文件，因为所有的功能都已经包含在可执行文件里了。
- **动态链接库**：程序在编译时并不复制库中的代码，而是在程序运行时加载库文件。这意味着库文件必须在程序运行时可用。

#### 2. 文件大小

- **静态链接库**通常会导致较大的可执行文件大小，因为所有使用的库代码都被复制进去了。
- **动态链接库**允许可执行文件小一些，因为代码是在运行时才被加载。

#### 3. 内存占用

- **静态链接库**的缺点是如果有多个程序使用相同的库，每个程序都有自己的副本，这将导致内存的浪费。
- **动态链接库**可以由多个正在运行的程序共享，只需在内存中有一个副本即可。

#### 4. 分发和更新

- **静态链接库**使得更新库变得复杂，因为每个应用都有自己的副本，所以每个应用都需要重新编译和分发。
- 使用**动态链接库**时，只需替换库文件并且确保API兼容性，所有使用该库的应用程序就可以直接利用新版本的库，无须重新编译。

#### 5. 跨平台兼容性

- **静态链接库**生成的可执行文件更易于在没有安装相应库的不同系统上运行，因为它们包括了所有需要的代码。
- 对于**动态链接库**，需要确保目标系统上存在正确版本的库文件。

#### 6. 链接错误和冲突

- **静态链接库**可能会引起版本冲突问题，尤其是当不同的库依赖同一个库但又各自静态链接了不同版本时。
- **动态链接库**可以减少这种冲突，因为同一份库文件被所有依赖它的程序共享。

### C++中右值引用有什么作用
C++11引入了右值引用，用来支持移动语义和完美转发。

1. 移动语义：传统的复制操作需要额外的时间和空间，而有了移动语义后，可以直接将资源（如内存）从一个对象转移到另一个对象，而不必创建并删除临时对象。这对于大对象或者拥有独占所有权资源的对象特别有用。例如，unique_ptr和std::vector等STL容器就利用了移动语义实现了高效的操作。
2. 完美转发：在函数模板中，我们想把参数原封不动地传递给其他函数。由于传参可能存在值传递、左值引用、常量左值引用、右值引用等情况，为了保证参数的属性和类型不发生变化，我们需要使用std::forward实现完美转发。

右值引用主要用于两种场景：一是对象的移动（Move），二是万能引用（Forwarding Reference）。对于第一种情况，它是为了解决对象的复制效率问题；对于第二种情况，则是为了实现参数的完美传递，避免不必要的拷贝。


### C++中四种cast的转换

1. **static_cast**： `static_cast` 是用于编译时检测到的相关类型之间的转换，比如整型和浮点数、派生类和基类之间的指针或引用转换。它不能用于含有虚函数的多态基类指针或引用到派生类的转换，因为这需要运行时信息。

   示例：

   ```
   int i = 10;
   float f = static_cast<float>(i);    // 整型到浮点数的转换
   ```

2. **dynamic_cast**： `dynamic_cast` 主要用于处理多态性。当涉及到继承体系中的向下转换（将基类的指针或引用转换为派生类类型）时，这个转换会检查转换的安全性。如果转换无效，对于指针，它会返回nullptr；对于引用，则抛出一个`std::bad_cast`异常。使用`dynamic_cast`需要运行时类型信息（RTTI），因此它有一定的性能代价。

   示例：

   ```
   Base* b = new Derived();   // 基类指针指向派生类对象
   Derived* d = dynamic_cast<Derived*>(b);   // 向下转型成功
   if (d) {
       // 转型有效，'d' 不是 nullptr
   }
   ```

3. **const_cast**： `const_cast` 用于移除或添加`const`或`volatile`属性。通常情况下，它被用于移除对象的常量性，允许修改原本被声明为`const`的变量。需要注意的是，去除一个本质上确实是常量的对象的`const`标记并进行修改可能会导致未定义行为。

   示例：

   ```
   const int ci = 10;
   int& modifiable = const_cast<int&>(ci);   // 移除常量性以便修改
   modifiable = 20;  // 注意：如果原对象真的是const，这里可能是未定义行为
   ```

4. **reinterpret_cast**： `reinterpret_cast` 是最危险的cast，它能够执行低级的强制类型转换。尽管几乎没有任何语义检查，但它能够在几乎任意两种类型之间转换，例如整数与指针之间的转换。由于它的不安全性，应该尽可能避免使用`reinterpret_cast`，除非你完全理解所进行的转换。

   示例：

   ```
   int* p = new int(65);
   char* ch = reinterpret_cast<char*>(p);  // 强制指针类型转换
   ```

总结：

- `static_cast`在相关类型间做安全转换。
- `dynamic_cast`在类层次结构中转换，并支持运行时检查。
- `const_cast`改变类型的`const`或`volatile`限定。
- `reinterpret_cast`进行低级别、不安全的强制类型转换。



### C++中常用的类优化技术有那些
1. 使用成员函数而非友元函数：将函数作为类的成员函数而不是友元函数可以提高封装性和代码可读性，并避免频繁地访问类的私有成员。
2. 使用引用参数而非传值参数：通过使用引用参数而不是传值参数来传递参数，可以减少内存开销和提高程序性能。特别是对于大型对象，避免了不必要的对象拷贝操作。
3. 使用移动语义：对于需要频繁进行资源管理的类，例如具有动态分配内存的类或具有文件句柄等资源的类，使用移动语义可以避免不必要的复制开销，提高程序效率。
4. 使用智能指针：在需要动态内存管理的情况下，使用智能指针（如 std::shared_ptr、std::unique_ptr 等）可以避免内存泄漏和悬空指针问题，提高代码的安全性和可靠性。
5. 使用const成员函数：将不会修改对象状态的函数声明为 const 成员函数可以提高类的接口清晰度，并增强代码的可维护性。
6. 避免不必要的动态内存分配：在设计类时，可以考虑避免过多的动态内存分配，尽量减少内存申请和释放的次数，以提高程序的性能和稳定性。
7. 使用内联函数：将简单的、频繁调用的函数声明为内联函数可以减少函数调用的开销，提高程序的执行效率。

### C++中类成员的访问权限有那些
1. **Public**:
   - 使用`public`标签指定的成员可以被任何访问该类对象的代码访问。
   - 公开成员定义了类的外部接口。
2. **Protected**:
   - 使用`protected`标签指定的成员只能被以下几种代码访问：
     - 类本身内部的成员函数。
     - 继承自该类的派生类中的成员函数。
   - 保护成员通常用于在基类和派生类之间共享数据或行为，同时对类的其他使用者隐藏这些细节。
3. **Private**:
   - 使用`private`标签指定的成员只能被类本身内部的成员函数（以及其友元）访问。
   - 私有成员是实现类内部封装的关键，防止了对类实现细节的外部访问。

下面是一个简单的类声明示例，展示了如何使用这三种不同的访问说明符：

```c++
class MyClass {
public:    // 公开成员
    int publicVariable;

    void publicMethod() {
        // ...
    }

protected: // 保护成员
    int protectedVariable;

    void protectedMethod() {
        // ...
    }

private:   // 私有成员
    int privateVariable;

    void privateMethod() {
        // ...
    }
};
```


### C++中结构体内存布局的规则是什么？
1. **成员顺序**: 结构体的成员变量在内存中按它们声明的顺序依次排列。
2. **数据对齐**: 为了提高访问速度，编译器会根据目标平台的要求对结构体成员进行对齐。这可能导致在成员之间或结构体末尾存在填充字节（padding）。
   - 对齐规则通常要求一个类型的数据地址必须是其大小的整数倍。例如，一个4字节的`int`通常需要放置在地址为4的倍数的位置上。
   - `#pragma pack`或编译器特定属性可用于改变或禁用默认的对齐行为。
3. **继承**: 如果结构体是从一个或多个其他结构体/类继承而来，则基类的成员将首先出现在派生类对象的内存中，后面跟着派生类自己的成员。
4. **虚函数**: 如果结构体有虚函数，编译器通常会在结构体的内存布局中加入一个指向虚函数表（vtable）的指针。这个指针位于对象的开始处，但具体位置取决于编译器的实现。
5. **虚继承**: 使用虚继承时，为了解决菱形继承问题，编译器会采取复杂的策略来安排内存布局，这通常涉及额外的指针和调整对象模型。
6. **静态成员**: 静态成员变量不作为结构体的一部分存储在每个对象的内存中，它们在全局/静态存储区有单独的存储空间。
7. **位域**: 如果结构体使用了位域，则相邻的位域可以被紧密打包以减少空间占用。但是，如果跨越了底层类型的边界，位域可能会被分割开。
8. **零大小数组**: 某些编译器允许在结构体末尾使用零大小数组作为柔性数组成员（flexible array member），而这通常不占用结构体的内存空间，只是作为一个符号占位符。

### C++中，结构体可以直接赋值吗？
结构体是一种用户自定义的数据类型，可以**像内置数据类型一样进行赋值操作**。结构体可以直接进行赋值，包括使用另外一个同类型的结构体来对它进行赋值。

```
struct Point {
    int x;
    int y;
};

int main() {
    Point p1 = {3, 4};
    Point p2;
    p2 = p1; // 可以直接将p1的值赋给p2
}

```

### C++内存分配

内存分配方式有三种：

（1）从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static变量。

（2）在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。

（3）从堆上分配，亦称动态内存分配。程序在运行的时候用malloc或new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存。动态内存的生存期由我们决定，使用非常灵活，但问题也最多。

c++运行时各类型内存分配（堆，栈，静态区，数据段，BSS，ELF），BSS段，
sizeof一个类求大小（字节对齐原则）、

### C++单例模式
在C++中，单例模式是一种设计模式，用来限制一个类只能创建一个对象。这对于需要全局访问点的情况非常有用，例如日志记录或者数据库连接。

下面是一个简单的单例模式的实现

```C++
class Singleton {
private:
    static Singleton* instance;
    // 私有构造函数，防止从其他地方创建对象。
    Singleton() {}

public:
    // 静态访问方法。
    static Singleton* getInstance() {
        if (instance == 0) {
            instance = new Singleton();
        }
        return instance;
    }
};

// 初始化指针为零，这样在第一次调用getInstance时可以初始化
Singleton* Singleton::instance = 0;

int main() {
    // 创建一个新的Singleton对象。
    Singleton* s = Singleton::getInstance();
   
    // 使用Singleton对象。

    return 0;
}

```

### C++多态的实现有那几种？他们有什么不同？
C++中，多态性主要通过两种方式实现：编译时多态（静态多态）和运行时多态（动态多态）。这两种多态的机制、特点和用途有所不同。

1. **编译时多态（静态多态）**: 编译时多态是在程序编译阶段实现的多态性。主要通过函数重载和运算符重载来实现。

   - **函数重载**: 同一个作用域内存在多个同名函数，但它们的参数类型或数量不同。根据调用时实际传递的参数类型和数量，编译器决定调用哪个函数。
   - **运算符重载**: 允许定义或重新定义大部分C++内置的运算符，使得它们可以根据操作数的类型执行不同的操作。

   **编译时多态的决策是在编译时做出的**，因此它不支持在运行时根据对象的实际类型来选择相应的成员函数。

2. **运行时多态（动态多态）**: 运行时多态是在程序运行阶段实现的多态性。它主要通过虚函数和继承来实现。

   - **虚函数**: 通过在基类中声明虚函数，允许派生类中重写该函数。当通过基类的指针或引用调用虚函数时，实际执行的是与指针或引用所指对象的实际类型相对应的函数版本。
   - **抽象类和纯虚函数**: 抽象类至少包含一个纯虚函数。纯虚函数在基类中没有实现，派生类必须重写这个函数。抽象类不能被实例化。

   **运行时多态的决策是在程序运行时做出的**，这就**需要运行时类型信息和虚函数表（vtable）**。在运行时，根据对象的实际类型来动态调用相应的成员函数，从而实现多态。

总的来说：

- **编译时多态**是静态的，主要通过函数重载和运算符重载来实现，决策发生在编译阶段。
- **运行时多态**是动态的，需要虚函数机制，并且决策发生在程序运行时。
- **运行时多态**能够提供更高的灵活性和扩展性，是实现框架和库中一些高级功能（如插件架构或事件处理系统）的关键。
- **编译时多态**由于在编译期就已经确定了调用哪个函数，通常性能更高，因为它避免了运行时查找虚函数表的开销。


### C++的atomic-bool代码底层是如何实现的
在C++中，`std::atomic` 是一个模板类，用于提供对基础类型的原子操作。`std::atomic<bool>` 是该模板类针对布尔类型的特化。原子操作保证了即使在多线程环境中，每个操作也是不可分割的，从而避免了竞态条件。

`std::atomic<bool>` 底层实现通常依赖于硬件和编译器的支持来提供原子性保证。具体实现可能涉及以下几个方面：

1. **内存屏障**（Memory Barriers/Fences）： 内存屏障用于确保指令的执行顺序，阻止编译器或者处理器重排操作顺序。
2. **锁前缀指令**（Lock Prefix）： 在x86架构中，处理器提供了带有`LOCK`前缀的指令，比如`LOCK XCHG`，它可以将操作变为原子性的。当CPU执行带有`LOCK`前缀的指令时，会确保指令完整执行，期间不会被其他处理器打断。
3. **特殊的原子指令**： 现代处理器提供了一系列原子指令，比如`XADD`（交换并加），`CMPXCHG`（比较并交换）等，可以用来实现原子变量。对于布尔变量，可能会使用这些指令来实现无锁的原子读写操作。
4. **编译器内建函数**（Compiler Intrinsics）： 编译器可能提供特殊的内建函数来映射到底层的原子指令。

例如，在GCC和Clang上，通常会使用GCC的内建函数来实现原子操作。例如：

```
bool old_value = __atomic_fetch_and(&my_atomic_bool, true, __ATOMIC_SEQ_CST);
```

这里的 `__atomic_fetch_and` 函数是GCC提供的内建函数，用于执行原子AND操作，并返回变量的旧值。第三个参数 `__ATOMIC_SEQ_CST` 表示使用最严格的内存顺序：Sequentially Consistent。

对于不支持原子指令的数据类型或复杂操作，可能需要使用锁（比如互斥锁）来保证操作的原子性。但由于 `bool` 类型非常简单，大多数平台都能够提供无锁的原子操作支持。

不同的平台和编译器可能有不同的实现方式，因此没有一个统一的实现细节。如果你想知道具体的实现，可以查看特定编译器的源代码或者汇编输出。


### C++的智能指针及其原理
#### 智能指针简介

C++的智能指针是一种用于管理动态分配内存的对象，它们提供了自动内存管理机制，避免了手动释放内存的繁琐和潜在的内存泄漏问题。

智能指针的原理基于RAII原则，即资源获取即初始化。智能指针通过在构造函数中获取资源（动态分配的内存），并在析构函数中释放资源，从而确保资源的正确释放。

C++标准库提供了两种主要的智能指针：`std::unique_ptr`和`std::shared_ptr`。

1. `std::unique_ptr`： `std::unique_ptr`是独占所有权的智能指针，它确保只有一个指针可以访问所管理的对象。当`std::unique_ptr`被销毁时，它会自动释放所拥有的对象。它不能被复制，但可以通过std::move()函数进行所有权转移。
2. `std::shared_ptr`： `std::shared_ptr`是共享所有权的智能指针，它可以被多个指针同时访问和共享所管理的对象。它使用引用计数来追踪有多少个指针指向该对象，当引用计数为0时，即没有任何指针指向对象时，资源会被释放。`std::shared_ptr`可以被复制和赋值。



注意：weak_ptr严格来说，不能算是“智能指针”，他只是一个类的弱引用，是用来解决两个`std::shared_ptr`相互进行引用的问题的



#### 侵入式和非侵入式的智能指针

在C++中，智能指针又被分为两种:侵入式和非侵入式的

1. **侵入式智能指针**： 侵入式智能指针需要被管理的类提供特定的接口或继承指定的基类，以支持智能指针的操作。这意味着被管理的类必须拥有与智能指针相关的成员函数或遵循特定的约定。侵入式智能指针可以更好地控制资源的生命周期，但需要修改被管理类的定义。

   例如，Boost库中的`boost::intrusive_ptr`就是一种侵入式智能指针。被管理的类必须实现`add_ref()`和`release()`等函数，以增加和释放引用计数。

2. **非侵入式智能指针**： 非侵入式智能指针不需要被管理的类提供额外的接口或继承特定的基类。它通过自身的机制来管理资源的生命周期，而不需要对被管理的类做任何修改。这样可以更方便地将智能指针应用到已有的类中。

   C++标准库中的`std::shared_ptr`就是一种非侵入式智能指针。它可以管理任何动态分配的对象，而不需要对被管理的类做任何特殊要求。

非侵入式智能指针相对于侵入式智能指针更加灵活和方便，但在某些情况下侵入式智能指针可能提供更细粒度的资源管理控制。选择使用哪种类型的智能指针取决于具体的需求和设计考虑。


### C++结构体内存对齐
C++中的结构体内存对齐是为了提高内存访问效率而采用的一种内存布局优化方式。在结构体中，根据处理器的架构和编译器设定的规则，可能会自动插入填充字节（padding），以确保结构体的成员变量按照一定的对齐方式存储。

以下是结构体内存对齐的基本原则：

1. 结构体的起始地址能够被其最宽基本类型成员的大小所整除。
2. 结构体中每个成员相对于结构体起始地址的偏移量（offset）都是该成员类型大小的整数倍，这就可能造成内存空间的浪费，即前面提到的填充字节。
3. 结构体的总大小为结构体最宽基本类型成员大小的整数倍，如果不足，会在结构体末尾添加填充字节。
4. 如果结构体中包含其他结构体或联合体，那么也需要按照这些内部结构体或联合体的对齐要求来对齐。

举例说明：

```
struct MyStruct {
    char a;        // 1字节
    int b;         // 4字节
    short c;       // 2字节
};
```

在上述结构体中，`int` 类型通常需要按照4字节对齐，在32位或64位架构下。假设编译器按照4字节对齐规则对该结构体进行内存对齐，则实际内存布局可能如下：

- `char a;` 占用1字节，后面跟着3字节的填充，以确保接下来的 `int b;` 能在4字节边界上对齐。
- `int b;` 直接按照4字节对齐，紧接着 `char a;` 后面的填充字节。
- `short c;` 占用2字节，并且因为已经处于4字节边界上，所以不需要额外填充。

结构体总大小：`sizeof(MyStruct)` 很可能是8个字节（1字节`char` + 3字节填充 + 4字节`int`），但实际上还有一个2字节的`short`，所以需要再加上2个字节的填充，使得整个结构体大小为12字节，满足最大对齐成员`int`的4字节的整数倍。

记住，具体的对齐情况取决于编译器设置（例如GCC的`__attribute__((packed))`、`#pragma pack`等）和目标平台的硬件架构。开发者可以通过这些手段来修改默认的对齐规则，以满足特定的内存或性能要求。

### Cookie和SessioN
#### Cookie

Cookie是存储在客户端（通常是用户的浏览器）上的小型数据片段。服务器通过HTTP响应头向浏览器发送Cookie，浏览器会将这些信息存储起来，并在之后的每个请求中通过HTTP请求头将Cookie发送回服务器。Cookie主要用于：

- 跟踪用户会话
- 存储用户偏好
- 实现自动登录等功能

Cookie数据是以键值对的形式存储的，每个Cookie都有过期时间，过期后会自动删除。由于Cookie存储在客户端，因此其容量受到限制（每个域名下大约4KB），且存在安全隐患，比如易于被篡改和第三方读取。

#### Session

Session是服务器端用来存储信息的机制。当用户访问Web应用时，服务器可以为该用户创建一个唯一的Session对象，并为这个会话分配一个唯一的Session ID。这个Session ID通常会通过Cookie发送给用户浏览器存储（尽管也有其他传输方式，如URL重写）。用户在后续请求中提交这个Session ID，服务器就能识别出对应的用户会话。

使用Session的目的是：

- 管理用户会话
- 存储用户特定的数据，如购物车内容、用户ID等

与Cookie相比，Session更加安全，因为数据存储在服务器端，外界无法直接访问。此外，由于存储在服务器，理论上可以存储更多的数据，不过这也会增加服务器的内存消耗。

#### Cookie与Session的关联

虽然Cookie和Session各有不同，但它们经常一起使用来管理用户会话。一个典型的流程是：

1. 用户首次访问网站时，服务器创建一个Session对象并生成一个唯一的Session ID。
2. 这个Session ID通过设置Cookie发送给用户浏览器。
3. 用户在后续的请求中，浏览器会自动将这个Session ID随着请求一起发送给服务器。
4. 服务器接收到Session ID后，识别出对应的用户会话，进行相应的处理。

### DNS和HTTP协议，HTTP请求方式
**DNS（域名系统）**:

- DNS是一个分布式的服务，它将人类可读的域名（如 [www.example.com](http://www.example.com/)）转换为机器可读的IP地址（如 192.0.2.1），使得用户能够通过域名访问网站而无需记住复杂的IP地址。
- 当你输入一个网址时，你的设备会使用DNS来查找对应的IP地址，从而能够连接到正确的服务器。
- DNS查询通常在用户感知不到的情况下在后台进行，并且大多使用UDP协议进行通信，因为它比TCP更快，而DNS查询需要速度。

**HTTP（超文本传输协议）**:

- HTTP是一种用于传输超媒体文档（例如HTML）的应用层协议。它构建在TCP/IP协议之上，主要用于Web浏览器和服务器之间的通信。
- HTTP工作在客户端-服务器架构上。用户的Web浏览器（客户端）会发起请求到服务器，服务器处理请求并返回响应。
- HTTP定义了一系列的请求方法，常见的包括GET、POST、PUT、DELETE等。

**HTTP请求方法**:

1. **GET**: 请求指定的页面信息，并返回实体主体。用于获取资源而不会影响资源状态。
2. **POST**: 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据包含在请求体中。POST请求可能会导致新的资源的建立或已有资源的修改。
3. **PUT**: 从客户端向服务器传送的数据取代指定的文档的内容。
4. **DELETE**: 请求服务器删除指定的页面。
5. **HEAD**: 类似于GET方法，但服务器将不返回实体的主体部分，用于获取报头。
6. **OPTIONS**: 允许客户端查看服务器的性能。
7. **PATCH**: 对资源进行部分修改。
8. **CONNECT**: 通常用于SSL加密服务器的通信以及代理服务器。
9. **TRACE**: 回显服务器收到的请求，主要用于测试或诊断。

这些方法各自有其特定的使用场景，它们共同构成了HTTP的一部分，让Web开发者可以根据不同的需求选择合适的方式来与服务器进行交互。


### DNS域名缓存是什么
#### 缓存目的和好处

DNS域名缓存的主要目的是减少对远端DNS服务器的查询次数，加快域名解析速度，减轻DNS服务器的负担，从而提高整个互联网的效率和性能。具体来说，DNS缓存带来的好处包括：

- **提高解析速度**：通过从缓存中直接获取解析结果，避免了每次都进行完整的DNS解析流程，大大加快了域名到IP地址的转换速度。
- **减少网络延迟**：由于减少了对远端DNS服务器的查询，从而降低了网络延迟。
- **减轻DNS服务器负担**：缓存可以显著减少DNS服务器接收的请求数量，有助于缓解服务器负载。

#### 缓存位置

1. **浏览器缓存**：现代Web浏览器都会维护自己的DNS缓存，以便重复访问的网站可以更快加载。
2. **操作系统缓存**：操作系统也会缓存DNS查询结果，当应用程序请求DNS解析时，首先会检查操作系统的DNS缓存。
3. **递归DNS服务器缓存**：当用户的查询请求发送到递归DNS服务器时，这些服务器也会缓存一份DNS查询结果，供后续相同的查询请求使用。
4. **权威DNS服务器**：虽然权威DNS服务器本身不缓存外部域名的解析结果，但它们会为自己负责的域名提供TTL（生存时间），告诉其他DNS服务器和客户端可以缓存解析结果的时间长度。


### HTTP中常用的状态码都有那些
#### 1xx：信息性状态码

- **100 Continue**：客户端应继续其请求

#### 2xx：成功

- **200 OK**：请求成功，对GET、PUT、PATCH或POST操作的标准响应
- **201 Created**：请求已经被实现，且新的资源已经被创建
- **204 No Content**：服务器成功处理了请求，但不需要返回任何实体内容

#### 3xx：重定向

- **301 Moved Permanently**：请求的页面已永久移动到新位置
- **302 Found**（之前“Moved Temporarily”）：服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求
- **304 Not Modified**：自从上次请求后，请求的网页未修改过

#### 4xx：客户端错误

- **400 Bad Request**：服务器无法理解请求的格式，客户端不应该再次尝试发送同样的请求
- **401 Unauthorized**：请求未经授权，这个状态代码必须和WWW-Authenticate报头一起使用
- **403 Forbidden**：服务器拒绝请求
- **404 Not Found**：请求失败，请求所希望得到的资源未被在服务器上发现
- **405 Method Not Allowed**：请求行中指定的请求方法不能被用于请求相应的资源

#### 5xx：服务器错误

- **500 Internal Server Error**：服务器遇到了一个未曾预料的状况，导致它无法完成对请求的处理
- **501 Not Implemented**：服务器不支持当前请求所需要的某个功能
- **502 Bad Gateway**：作为网关或代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应
- **503 Service Unavailable**：由于临时的服务器维护或过载，服务器当前无法处理请求
- **504 Gateway Timeout**：作为网关或代理的服务器，未能及时从上游服务器或辅助服务器接收请求

### HTTP方法都有那些
1. **GET**：请求指定的资源。GET请求应该只用于获取数据，并且不应当引起服务器上资源状态的改变。
2. **POST**：向指定的资源提交数据以进行处理（例如，提交表单或上传文件）。数据包含在请求体中。POST请求可能会创建新的资源或修改现有资源。
3. **PUT**：将请求体中的数据发送到指定的资源以创建或替换该资源。相对于POST，PUT具有幂等性，意味着多次执行相同的PUT请求应该产生相同的结果。
4. **DELETE**：删除指定的资源。
5. **HEAD**：与GET方法类似，但服务器在响应中只返回头部信息，不返回实际的资源内容。这常用于检测资源的有效性或最近更新时间。
6. **OPTIONS**：描述目标资源的通信选项，用于确定服务器支持的HTTP方法。
7. **PATCH**：对资源应用部分修改。它比PUT更加精细，只更新资源的一部分而不是整个资源。
8. **CONNECT**：将连接转换为透明的TCP/IP隧道，通常用于SSL加密服务器的代理（通过CONNECT方法将请求转发给HTTPS端口）。
9. **TRACE**：执行一个消息回环测试，沿路径回显收到的请求。这允许客户端看到请求被中间服务器添加的或修改的字段。

### HTTP长连接和短链接都用在那些场景
#### 短连接

在短连接模式下，客户端与服务器之间的每个请求/响应对都会打开一个新的连接，并在交换完成后立即关闭连接。短连接适用于以下场景：

- **低频请求**：如果客户端只偶尔与服务器通信，使用短连接可以减少服务器维护空闲连接所需的资源。
- **简单的请求/响应交互**：对于简单且数量不多的请求，短连接可以快速建立，完成数据交换后即刻释放资源。
- **负载分配**：在负载均衡的环境中，短连接有助于将来自不同客户端的请求更公平地分配到不同的服务器。

#### 长连接

HTTP/1.1默认采用长连接（持久连接），在此模式下，TCP连接在多个请求/响应之间保持开放状态，直到由客户端或服务器明确关闭。长连接适合于：

- **高频请求**：当客户端需要频繁地向服务器发送请求时，长连接减少了因为建立和关闭连接而带来的额外开销。
- **减少延迟**：对于需要快速响应的应用，如网页浏览和在线游戏，长连接能够减少每次请求所需的往返时间（RTT），提高用户体验。
- **实时通信**：在聊天应用、实时数据更新等场景中，长连接可以保持一个持续的数据流，允许服务器主动向客户端推送信息。

### Innodb和Myisam的区别
数据库引擎是用于存储、处理和保护数据的核心服务

1.事务

InnoDB 支持事务，事务安全。Myisam 非事务安全，也不支持事务

2.锁

innoDb 行级锁，myisam 针对表加锁

3.索引

innodb 不支持全文索引，myisam 支持全局索引

4.适用场景

myisam 效率快于 innodb ，适用于小型应用，扩平台支持。大量查询 select

innodb 支持事务，也有 ACID 的特性还有 insert update 对于事务的控制操作

### Linux上有个二进制程序一直在运行，我修改代码置换重新编译把原来的二进制程序覆盖了，会怎么样
在Linux系统中，如果一个正在运行的二进制程序被覆盖（即，文件内容被新的编译版本替换），通常情况下运行中的程序不会受到影响。这是因为当程序启动时，它的可执行文件内容会被加载到内存中，操作系统会维护对这些数据的引用，并且即便原始的文件系统上的可执行文件被覆盖或删除，这些内存映射通常仍然有效。


但是，替换正在运行的二进制文件并不会影响到当前运行中的进程，**但会影响后续启动的进程**，**因为后续运行的文件就会使用文件的最新版本进行运行**。


此外，面试的时候可以加上一个和**共享库的区别**：**共享库一般依赖于动态链接，所以如果在保证兼容性的情况下是可以进行热更新的，就是更新文件的同时更新程序，但是这要和程序本身做区分**


### MySQL的主从复制是如何实现的
1. **日志文件和位置（Binary Log and Position）**：
   - 主服务器上的所有数据更改（如INSERT、UPDATE、DELETE等）都会记录在二进制日志（Binary Log）中。这个日志包含了所有更改数据的事件以及标识这些事件位置的日志点（Log Position）。
2. **配置主服务器**：
   - 在主服务器上，需要启用二进制日志，并配置一个唯一的服务器ID。
3. **配置从服务器**：
   - 在从服务器上，也需要配置一个唯一的服务器ID，它与主服务器的ID不同。
   - 设置从服务器以连接到主服务器，并指定要开始复制的二进制日志文件名和日志位置。
   - 从服务器会启动两个重要的线程：I/O线程和SQL线程。
     - **I/O线程**：连接到主服务器并请求从指定的日志文件和位置开始复制数据，然后将接收到的二进制日志事件复制到从服务器的中继日志（Relay Log）。
     - **SQL线程**：读取中继日志中的事件并在从服务器上重新执行这些事件，以此来更新从服务器上的数据。
4. **数据复制过程**：
   - 主服务器的二进制日志被不断记录数据变更。
   - 从服务器的I/O线程从主服务器请求并获取二进制日志的更新，并将它们写入中继日志。
   - 从服务器的SQL线程读取中继日志中的事件，并将这些事件应用到从服务器的数据库中，确保与主服务器的数据一致。
5. **监控和维护**：
   - 复制过程可以监控各种状态和性能指标，如延迟、错误和日志文件的大小。
   - 维护复制环境可能涉及处理错误、重新同步数据和升级服务器。


### MySQL的行级锁有那些种类？
1. **记录锁（Record Locks）**
   - 基本的行级锁，直接作用于索引记录上。
2. **间隙锁（Gap Locks）**
   - 锁定一个范围，但不包括记录本身，主要用于防止幻读（phantom reads）。
3. **临键锁（Next-Key Locks）**
   - 是记录锁和间隙锁的组合，锁定一个范围并且包括记录本身。临键锁可以防止幻读，并且是InnoDB默认的行级锁形式。


### NGINX在Linux上是如何工作的？简单描述一下
1. **事件驱动与非阻塞I/O**：Nginx的Worker进程内部使用了异步非阻塞的I/O处理方式和事件驱动的机制来处理请求。Nginx可以处理大量并发连接，而且每个Worker进程都可以同时处理多个请求，这意味着Nginx可以支持高并发且高效率。
2. **反向代理和负载均衡**：Nginx可以设置成反向代理服务器，在这种模式下，Nginx可以接收客户端的请求，然后将该请求转发到后端的其他服务器，并将从后端服务器获取的响应返回给客户端。同时，Nginx也提供负载均衡功能，可以根据预设的策略（如轮询、最少连接等）将请求分发到不同的后端服务器。
3. **静态资源服务**：对于静态资源的请求，Nginx可以直接读取磁盘上的静态文件（如HTML、CSS、JavaScript文件或图片等）并返回。
4. **（可选，如果你不了解面试建议不说）Master-Worker架构**：Nginx采用了Master-Worker的模型。在启动Nginx服务时，首先会有一个Master进程被创建出来，在这个Master进程中，会创建多个Worker进程。Master进程主要负责管理Worker进程，包括读取并验证配置信息、创建、绑定套接字然后传递给worker进程、启动、关闭、维护worker进程等。而Worker进程则负责处理实际的请求。


### OSI七层模型分别是？各自的功能分别是什么
#### 1. 物理层

**功能：** 物理层负责数据在物理媒介上的传输，将来自数据链路层的数据帧转换为电信号、光信号或无线信号。它涉及的范围包括电缆类型、接口形状、引脚数量等。

#### 2. 数据链路层

**功能：** 数据链路层管理介质访问控制并进行错误检测与纠正。它将Raw位流组织成逻辑结构称为“数据帧”，并在两个相邻节点之间传输这些帧。此层还负责流量控制和帧同步。

#### 3. 网络层

**功能：** 网络层负责设备间的数据传输和寻址。它决定数据的路径路由，并使用IP地址和子网划分来导向目标位置。它也处理分组路由、拥塞控制和网络互联问题。

#### 4. 传输层

**功能：** 传输层提供端到端的通信服务。它负责数据的分段和重组，并保证数据完整性。主要协议有TCP和UDP，分别提供可靠的连接和不可靠的连接。

#### 5. 会话层

**功能：** 会话层建立、管理和终止应用程序之间的会话。它的职责是建立和维护持久的数据通信会话，并在必要时重新启动会话。

#### 6. 表示层

**功能：** 表示层负责数据的编码、转换和解压。它确保来自应用层的数据被网络格式化为适合传输的格式，并在达到目标后被恢复原样。它还可以处理加密和解密。

#### 7. 应用层

**功能：** 应用层为最终用户提供网络服务接口。它直接支持各种端用户应用，如Web浏览器、Email客户端、远程文件服务等。此层负责识别和建立与远程应用的通信。

### POST和GET的主要区别有那些
1. **语义上的区别**：
   - GET请求通常用于请求服务器发送资源或数据。它意味着获取信息，而不应该引起服务器上任何资源的状态改变。
   - POST请求则用于向服务器提交数据以创建或更新资源。它通常会引起服务器上资源的状态变化或副作用。
2. **数据传输位置**：
   - 在GET请求中，数据附加在URL之后作为查询字符串参数进行发送，形式为`?key1=value1&key2=value2`。
   - POST请求将数据包含在请求体中发送给服务器，这意味着数据不会出现在URL中，适合传输敏感信息或大量数据。
3. **数据大小限制**：
   - GET请求由于数据直接附加在URL后面，因此受到URL长度限制（由浏览器和服务器决定），通常不适合传输大量数据。
   - POST请求没有这样的限制，理论上可以传输更多数据，更适合大量数据的传输。
4. **安全性和隐私**：
   - GET请求中的数据暴露在URL中，可能会被浏览器历史、Web服务器日志等记录下来，因此不适合传输敏感信息。
   - POST请求中的数据在请求体内，不会直接暴露在URL中，相对更安全。
5. **缓存和书签**：
   - GET请求可以被缓存，也可以保存为书签。
   - POST请求不会被缓存，也不能保存为书签。


### STL中一般都有那些常见的算法库呢
一般常见的STL算法库包括：

1. 非修改性序列操作算法：如std::for_each, std::count, std::find, std::binary_search等。
2. 修改性序列操作算法：如std::sort, std::reverse, std::swap, std::rotate等。
3. 排列组合算法：如std::next_permutation, std::prev_permutation, std::merge等。
4. 数值操作算法：如std::accumulate, std::inner_product, std::partial_sum等。
5. 堆操作算法：如std::make_heap, std::push_heap, std::pop_heap等。
6. 划分操作算法：如std::partition, std::stable_partition等。

### STL中的优先级队列是如何实现的？
在 C++ STL 中，`std::priority_queue` 默认情况下使用 `std::vector` 作为其底层容器，并且使用 `std::make_heap`、`std::push_heap` 和 `std::pop_heap` 算法来维护堆的性质。

`std::priority_queue` 允许用户指定一个比较函数对象，这个比较对象定义了元素的优先级。默认情况下，它使用 `std::less<T>`，这意味着队列使用最大堆，最大的元素总






























































































































